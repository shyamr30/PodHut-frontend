{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useEffect, useRef } from \"react\";\nimport { useStateWithCallback } from \"./useStateWithCallback\";\nimport { socketInit } from '../socket/index';\nimport { ACTIONS } from '../actions';\nimport freeice from 'freeice';\nexport const useWebRTC = (roomId, user) => {\n  _s();\n\n  const [clients, setClients] = useStateWithCallback([]);\n  const audioElements = useRef({});\n  const connections = useRef({});\n  const localMediaStream = useRef(null);\n  const socket = useRef(null);\n  useEffect(() => {\n    socket.current = socketInit();\n  }, []);\n\n  const provideRef = (instance, userId) => {\n    audioElements.current[userId] = instance;\n  };\n\n  const addNewClient = useCallback((newClient, cb) => {\n    const lookingFor = clients.find(client => client.id === newClient.id);\n\n    if (lookingFor === undefined) {\n      setClients(existingClients => [...existingClients, newClient], cb);\n    }\n  }, [clients, setClients]); //capture media\n\n  useEffect(() => {\n    const startCapture = async () => {\n      localMediaStream.current = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n    };\n\n    startCapture().then(() => {\n      addNewClient(user, () => {\n        const localElement = audioElements.current[user.id];\n\n        if (localElement) {\n          localElement.volume = 0;\n          localElement.srcObject = localMediaStream.current;\n        } //socket emit JOIN socket.io\n\n\n        socket.current.emit(ACTIONS.JOIN, {\n          roomId,\n          user\n        });\n      });\n    });\n    return () => {\n      //leaving the room\n      localMediaStream.current.getTracks().forEach(track => track.stop());\n      socket.current.emit(ACTIONS.LEAVE, {\n        roomId\n      });\n    };\n  }, []);\n  useEffect(() => {\n    const handleNewPeer = async _ref => {\n      let {\n        peerId,\n        createOffer,\n        user: remoteUser\n      } = _ref;\n\n      // if already connected then give warning\n      if (peerId in connections.current) {\n        return console.warn(`You are already connected with ${peerId} (${user.name})`);\n      }\n\n      connections.current[peerId] = new RTCPeerConnection({\n        iceServers: freeice()\n      }); // handle new ice candidates\n\n      connections.current[peerId].onicecandidate = event => {\n        socket.current.emit(ACTIONS.RELAY_ICE, {\n          peerId,\n          icecandidate: event.candidate\n        });\n      }; // handle on track on this connections\n\n\n      connections.current[peerId].ontrack = _ref2 => {\n        let {\n          streams: [remoteStream]\n        } = _ref2;\n        addNewClient(remoteUser, () => {\n          if (audioElements.current[remoteUser.id]) {\n            audioElements.current[remoteUser.id].srcObject = remoteStream;\n          } else {\n            let settled = false;\n            const interval = setInterval(() => {\n              if (audioElements.current[remoteUser.id]) {\n                audioElements.current[remoteUser.id].srcObject = remoteStream;\n                settled = true;\n              }\n\n              if (settled) {\n                clearInterval(interval);\n              }\n            }, 1000);\n          }\n        });\n      }; // add local track to remote connections \n\n\n      localMediaStream.current.getTracks().forEach(track => {\n        connections.current[peerId].addTrack(track, localMediaStream.current);\n      }); //create offer\n\n      if (createOffer) {\n        const offer = await connections.current[peerId].createOffer();\n        await connections.current[peerId].setLocalDescription(offer); //send offer to another client\n\n        socket.current.emit(ACTIONS.RELAY_SDP, {\n          peerId,\n          sessionDescription: offer\n        });\n      }\n    };\n\n    socket.current.on(ACTIONS.ADD_PEER, handleNewPeer);\n    return () => {\n      socket.current.off(ACTIONS.ADD_PEER);\n    };\n  }, []); // handle ice candidate\n\n  useEffect(() => {\n    socket.current.on(ACTIONS.ICE_CANDIDATE, _ref3 => {\n      let {\n        peerId,\n        icecandidate\n      } = _ref3;\n\n      if (icecandidate) {\n        connections.current[peerId].addIceCandidate(icecandidate);\n      }\n    });\n    return () => {\n      socket.current.off(ACTIONS.ICE_CANDIDATE);\n    };\n  }, []); //handle sdp\n\n  useEffect(() => {\n    const handleRemoteSdp = async _ref4 => {\n      let {\n        peerId,\n        sessionDescription: remoteSessionDescription\n      } = _ref4;\n      connections.current[peerId].setRemoteDescription(new RTCSessionDescription(remoteSessionDescription)); //if session description is offer then create answer\n\n      if (remoteSessionDescription === 'offer') {\n        const connection = connections.current[peerId];\n        const answer = await connection.createAnswer();\n        connection.setLocalDescription(answer);\n        socket.current.emit(ACTIONS.RELAY_SDP, {\n          peerId,\n          sessionDescription: answer\n        });\n      }\n    };\n\n    socket.current.on(ACTIONS.SESSION_DESCRIPTION, handleRemoteSdp);\n    return () => {\n      socket.current.off(ACTIONS.SESSION_DESCRIPTION);\n    };\n  }, []); //handle remove peer\n\n  useEffect(() => {\n    const handleRemovePeer = async _ref5 => {\n      let {\n        peerId,\n        userId\n      } = _ref5;\n\n      if (connections.current[peerId]) {\n        connections.current[peerId].close();\n      }\n\n      delete connections.current[peerId];\n      delete audioElements.current[peerId];\n      setClients(list => list.filter(client => client.id !== userId));\n    };\n\n    socket.current.on(ACTIONS.REMOVE_PEER, handleRemovePeer);\n    return () => {\n      socket.current.off(ACTIONS.REMOVE_PEER);\n    };\n  }, []);\n  return {\n    clients,\n    provideRef\n  };\n};\n\n_s(useWebRTC, \"ksM9rSuLqu6dP4rwJKw4UMLpEwY=\", false, function () {\n  return [useStateWithCallback];\n});","map":{"version":3,"sources":["E:/College Assignment/Sem 6/SDP Project/project/frontend/src/hooks/useWebRTC.js"],"names":["useCallback","useEffect","useRef","useStateWithCallback","socketInit","ACTIONS","freeice","useWebRTC","roomId","user","clients","setClients","audioElements","connections","localMediaStream","socket","current","provideRef","instance","userId","addNewClient","newClient","cb","lookingFor","find","client","id","undefined","existingClients","startCapture","navigator","mediaDevices","getUserMedia","audio","then","localElement","volume","srcObject","emit","JOIN","getTracks","forEach","track","stop","LEAVE","handleNewPeer","peerId","createOffer","remoteUser","console","warn","name","RTCPeerConnection","iceServers","onicecandidate","event","RELAY_ICE","icecandidate","candidate","ontrack","streams","remoteStream","settled","interval","setInterval","clearInterval","addTrack","offer","setLocalDescription","RELAY_SDP","sessionDescription","on","ADD_PEER","off","ICE_CANDIDATE","addIceCandidate","handleRemoteSdp","remoteSessionDescription","setRemoteDescription","RTCSessionDescription","connection","answer","createAnswer","SESSION_DESCRIPTION","handleRemovePeer","close","list","filter","REMOVE_PEER"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef } from \"react\";\r\nimport { useStateWithCallback } from \"./useStateWithCallback\";\r\nimport {socketInit} from '../socket/index';\r\nimport {ACTIONS} from '../actions';\r\nimport freeice from 'freeice';\r\n\r\n\r\nexport const useWebRTC = (roomId, user) => {\r\n    const [clients, setClients] = useStateWithCallback([]);\r\n    const audioElements = useRef({});\r\n    const connections = useRef({});\r\n    const localMediaStream = useRef(null);\r\n    const socket = useRef(null);\r\n    useEffect(() => {\r\n        socket.current = socketInit();\r\n    },[])\r\n\r\n    const provideRef = (instance, userId) => {\r\n        audioElements.current[userId] = instance;\r\n    };\r\n\r\n    const addNewClient = useCallback((newClient, cb) => {\r\n            const lookingFor = clients.find((client) => client.id === newClient.id);\r\n            if(lookingFor === undefined) {\r\n                setClients((existingClients) => [...existingClients, newClient], cb);\r\n            }\r\n        },\r\n        [clients,setClients],\r\n    );\r\n    //capture media\r\n    useEffect(() => {\r\n        const startCapture = async () => {\r\n            localMediaStream.current = await navigator.mediaDevices.getUserMedia({\r\n                audio: true\r\n            });\r\n        };\r\n        startCapture().then(() => {\r\n            addNewClient(user, () => {\r\n                const localElement = audioElements.current[user.id];\r\n                if(localElement) {\r\n                    localElement.volume = 0;\r\n                    localElement.srcObject = localMediaStream.current;\r\n                }\r\n\r\n                //socket emit JOIN socket.io\r\n                socket.current.emit(ACTIONS.JOIN, {roomId, user});\r\n            });\r\n        });\r\n\r\n        return  () => {\r\n            //leaving the room\r\n            localMediaStream.current.getTracks().forEach(\r\n                track => track.stop());\r\n            socket.current.emit(ACTIONS.LEAVE, {roomId});\r\n        }\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        const handleNewPeer = async ({peerId, createOffer, user: remoteUser}) => {\r\n            // if already connected then give warning\r\n            if(peerId in connections.current) {\r\n                return console.warn(`You are already connected with ${peerId} (${user.name})`);\r\n            }\r\n\r\n            connections.current[peerId] = new RTCPeerConnection({\r\n                iceServers: freeice()\r\n            });\r\n            // handle new ice candidates\r\n            connections.current[peerId].onicecandidate = (event) => {\r\n                socket.current.emit(ACTIONS.RELAY_ICE, {\r\n                    peerId,\r\n                    icecandidate: event.candidate,\r\n                });\r\n            }\r\n\r\n            // handle on track on this connections\r\n            connections.current[peerId].ontrack = ({\r\n                streams: [remoteStream]\r\n            }) => {\r\n                addNewClient(remoteUser, () => {\r\n                    if(audioElements.current[remoteUser.id]) {\r\n                        audioElements.current[remoteUser.id].srcObject = remoteStream\r\n                    }\r\n                    else{\r\n                        let settled = false;\r\n                        const interval = setInterval(() => {\r\n                            if(audioElements.current[remoteUser.id]) {\r\n                                audioElements.current[remoteUser.id].srcObject = remoteStream\r\n                                settled = true;\r\n                            }\r\n                            if(settled) {\r\n                                clearInterval(interval);\r\n                            }\r\n                        }, 1000);\r\n                    }\r\n                })\r\n            }\r\n\r\n            // add local track to remote connections \r\n            localMediaStream.current.getTracks().forEach(track => {\r\n                connections.current[peerId].addTrack(track, localMediaStream.current);\r\n            });\r\n            //create offer\r\n            if(createOffer) {\r\n                const offer = await connections.current[peerId].createOffer();\r\n                await connections.current[peerId].setLocalDescription(offer);\r\n                //send offer to another client\r\n                socket.current.emit(ACTIONS.RELAY_SDP, {\r\n                    peerId,\r\n                    sessionDescription: offer,\r\n                });\r\n            }\r\n        };\r\n\r\n        socket.current.on(ACTIONS.ADD_PEER, handleNewPeer);\r\n        return () => {\r\n            socket.current.off(ACTIONS.ADD_PEER);\r\n        }\r\n    }, []);\r\n\r\n    // handle ice candidate\r\n    useEffect(() => {\r\n        socket.current.on(ACTIONS.ICE_CANDIDATE, ({peerId, icecandidate}) => {\r\n            if(icecandidate) {\r\n                connections.current[peerId].addIceCandidate(icecandidate);\r\n            }\r\n        })\r\n\r\n        return () => {\r\n            socket.current.off(ACTIONS.ICE_CANDIDATE);\r\n        };\r\n    }, []);\r\n\r\n    //handle sdp\r\n    useEffect(() => {\r\n\r\n        const handleRemoteSdp = async ({peerId, sessionDescription: remoteSessionDescription}) => {\r\n            connections.current[peerId].setRemoteDescription(\r\n                new RTCSessionDescription(remoteSessionDescription)\r\n            )\r\n\r\n            //if session description is offer then create answer\r\n            if(remoteSessionDescription === 'offer'){\r\n                const connection = connections.current[peerId];\r\n                const answer = await connection.createAnswer();\r\n                connection.setLocalDescription(answer);\r\n\r\n                socket.current.emit(ACTIONS.RELAY_SDP, {\r\n                    peerId,\r\n                    sessionDescription: answer,\r\n                });\r\n            }\r\n        };\r\n        socket.current.on(ACTIONS.SESSION_DESCRIPTION, handleRemoteSdp);\r\n\r\n        return () => {\r\n            socket.current.off(ACTIONS.SESSION_DESCRIPTION);\r\n        };\r\n    }, []);\r\n\r\n    //handle remove peer\r\n    useEffect(() => {\r\n        const handleRemovePeer = async({peerId, userId}) => {\r\n            if(connections.current[peerId]) {\r\n                connections.current[peerId].close();\r\n            }\r\n            delete connections.current[peerId];\r\n            delete audioElements.current[peerId];\r\n            setClients(list => list.filter(client => client.id !== userId));\r\n        }\r\n\r\n        socket.current.on(ACTIONS.REMOVE_PEER, handleRemovePeer);\r\n\r\n        return () => {\r\n            socket.current.off(ACTIONS.REMOVE_PEER);\r\n        };\r\n    }, [])\r\n\r\n    return {clients, provideRef};\r\n}"]},"metadata":{},"sourceType":"module"}
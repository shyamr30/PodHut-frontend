{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState, useRef, useCallback } from 'react';\nimport { ACTIONS } from '../actions';\nimport socketInit from '../socket';\nimport freeice from 'freeice';\nimport { useStateWithCallback } from './useStateWithCallback';\nexport const useWebRTC = (roomId, user) => {\n  _s();\n\n  const [clients, setClients] = useStateWithCallback([]);\n  const audioElements = useRef({});\n  const connections = useRef({});\n  const socket = useRef(null);\n  const localMediaStream = useRef(null);\n  const clientsRef = useRef(null);\n  const addNewClient = useCallback((newClient, cb) => {\n    const lookingFor = clients.find(client => client.id === newClient.id);\n\n    if (lookingFor === undefined) {\n      setClients(existingClients => [...existingClients, newClient], cb);\n    }\n  }, [clients, setClients]);\n  useEffect(() => {\n    clientsRef.current = clients;\n  }, [clients]);\n  useEffect(() => {\n    const initChat = async () => {\n      socket.current = socketInit();\n      await captureMedia();\n      addNewClient({ ...user,\n        muted: true\n      }, () => {\n        const localElement = audioElements.current[user.id];\n\n        if (localElement) {\n          localElement.volume = 0;\n          localElement.srcObject = localMediaStream.current;\n        }\n      });\n      socket.current.on(ACTIONS.MUTE_INFO, _ref => {\n        let {\n          userId,\n          isMute\n        } = _ref;\n        handleSetMute(isMute, userId);\n      });\n      socket.current.on(ACTIONS.ADD_PEER, handleNewPeer);\n      socket.current.on(ACTIONS.REMOVE_PEER, handleRemovePeer);\n      socket.current.on(ACTIONS.ICE_CANDIDATE, handleIceCandidate);\n      socket.current.on(ACTIONS.SESSION_DESCRIPTION, setRemoteMedia);\n      socket.current.on(ACTIONS.MUTE, _ref2 => {\n        let {\n          peerId,\n          userId\n        } = _ref2;\n        handleSetMute(true, userId);\n      });\n      socket.current.on(ACTIONS.UNMUTE, _ref3 => {\n        let {\n          peerId,\n          userId\n        } = _ref3;\n        handleSetMute(false, userId);\n      });\n      socket.current.emit(ACTIONS.JOIN, {\n        roomId,\n        user\n      });\n\n      async function captureMedia() {\n        // Start capturing local audio stream.\n        localMediaStream.current = await navigator.mediaDevices.getUserMedia({\n          audio: true\n        });\n      }\n\n      async function handleNewPeer(_ref4) {\n        let {\n          peerId,\n          createOffer,\n          user: remoteUser\n        } = _ref4;\n\n        if (peerId in connections.current) {\n          return console.warn(`You are already connected with ${peerId} (${user.name})`);\n        } // Store it to connections\n\n\n        connections.current[peerId] = new RTCPeerConnection({\n          iceServers: freeice()\n        }); // Handle new ice candidate on this peer connection\n\n        connections.current[peerId].onicecandidate = event => {\n          socket.current.emit(ACTIONS.RELAY_ICE, {\n            peerId,\n            icecandidate: event.candidate\n          });\n        }; // Handle on track event on this connection\n\n\n        connections.current[peerId].ontrack = _ref5 => {\n          let {\n            streams: [remoteStream]\n          } = _ref5;\n          addNewClient({ ...remoteUser,\n            muted: true\n          }, () => {\n            // get current users mute info\n            const currentUser = clientsRef.current.find(client => client.id === user.id);\n\n            if (currentUser) {\n              socket.current.emit(ACTIONS.MUTE_INFO, {\n                userId: user.id,\n                roomId,\n                isMute: currentUser.muted\n              });\n            }\n\n            if (audioElements.current[remoteUser.id]) {\n              audioElements.current[remoteUser.id].srcObject = remoteStream;\n            } else {\n              let settled = false;\n              const interval = setInterval(() => {\n                if (audioElements.current[remoteUser.id]) {\n                  audioElements.current[remoteUser.id].srcObject = remoteStream;\n                  settled = true;\n                }\n\n                if (settled) {\n                  clearInterval(interval);\n                }\n              }, 300);\n            }\n          });\n        }; // Add connection to peer connections track\n\n\n        localMediaStream.current.getTracks().forEach(track => {\n          connections.current[peerId].addTrack(track, localMediaStream.current);\n        }); // Create an offer if required\n\n        if (createOffer) {\n          const offer = await connections.current[peerId].createOffer(); // Set as local description\n\n          await connections.current[peerId].setLocalDescription(offer); // send offer to the server\n\n          socket.current.emit(ACTIONS.RELAY_SDP, {\n            peerId,\n            sessionDescription: offer\n          });\n        }\n      }\n\n      async function handleRemovePeer(_ref6) {\n        let {\n          peerId,\n          userId\n        } = _ref6;\n\n        // Correction: peerID to peerId\n        if (connections.current[peerId]) {\n          connections.current[peerId].close();\n        }\n\n        delete connections.current[peerId];\n        delete audioElements.current[peerId];\n        setClients(list => list.filter(c => c.id !== userId));\n      }\n\n      async function handleIceCandidate(_ref7) {\n        let {\n          peerId,\n          icecandidate\n        } = _ref7;\n\n        if (icecandidate) {\n          connections.current[peerId].addIceCandidate(icecandidate);\n        }\n      }\n\n      async function setRemoteMedia(_ref8) {\n        let {\n          peerId,\n          sessionDescription: remoteSessionDescription\n        } = _ref8;\n        connections.current[peerId].setRemoteDescription(new RTCSessionDescription(remoteSessionDescription)); // If session descrition is offer then create an answer\n\n        if (remoteSessionDescription.type === 'offer') {\n          const connection = connections.current[peerId];\n          const answer = await connection.createAnswer();\n          connection.setLocalDescription(answer);\n          socket.current.emit(ACTIONS.RELAY_SDP, {\n            peerId,\n            sessionDescription: answer\n          });\n        }\n      }\n\n      async function handleSetMute(mute, userId) {\n        const clientIdx = clientsRef.current.map(client => client.id).indexOf(userId);\n        const allConnectedClients = JSON.parse(JSON.stringify(clientsRef.current));\n\n        if (clientIdx > -1) {\n          allConnectedClients[clientIdx].muted = mute;\n          setClients(allConnectedClients);\n        }\n      }\n    };\n\n    initChat();\n    return () => {\n      localMediaStream.current.getTracks().forEach(track => track.stop());\n      socket.current.emit(ACTIONS.LEAVE, {\n        roomId\n      });\n\n      for (let peerId in connections.current) {\n        connections.current[peerId].close();\n        delete connections.current[peerId];\n        delete audioElements.current[peerId];\n      }\n\n      socket.current.off(ACTIONS.ADD_PEER);\n      socket.current.off(ACTIONS.REMOVE_PEER);\n      socket.current.off(ACTIONS.ICE_CANDIDATE);\n      socket.current.off(ACTIONS.SESSION_DESCRIPTION);\n      socket.current.off(ACTIONS.MUTE);\n      socket.current.off(ACTIONS.UNMUTE);\n    };\n  }, []);\n\n  const provideRef = (instance, userId) => {\n    audioElements.current[userId] = instance;\n  };\n\n  const handleMute = (isMute, userId) => {\n    let settled = false;\n\n    if (userId === user.id) {\n      let interval = setInterval(() => {\n        if (localMediaStream.current) {\n          localMediaStream.current.getTracks()[0].enabled = !isMute;\n\n          if (isMute) {\n            socket.current.emit(ACTIONS.MUTE, {\n              roomId,\n              userId: user.id\n            });\n          } else {\n            socket.current.emit(ACTIONS.UNMUTE, {\n              roomId,\n              userId: user.id\n            });\n          }\n\n          settled = true;\n        }\n\n        if (settled) {\n          clearInterval(interval);\n        }\n      }, 200);\n    }\n  };\n\n  return {\n    clients,\n    provideRef,\n    handleMute\n  };\n};\n\n_s(useWebRTC, \"3TvHJpyJNNvMGFf9ptUfUUM9qII=\", false, function () {\n  return [useStateWithCallback];\n});","map":{"version":3,"sources":["D:/8th sem/project/frontend/src/hooks/useWebRTC.js"],"names":["useEffect","useState","useRef","useCallback","ACTIONS","socketInit","freeice","useStateWithCallback","useWebRTC","roomId","user","clients","setClients","audioElements","connections","socket","localMediaStream","clientsRef","addNewClient","newClient","cb","lookingFor","find","client","id","undefined","existingClients","current","initChat","captureMedia","muted","localElement","volume","srcObject","on","MUTE_INFO","userId","isMute","handleSetMute","ADD_PEER","handleNewPeer","REMOVE_PEER","handleRemovePeer","ICE_CANDIDATE","handleIceCandidate","SESSION_DESCRIPTION","setRemoteMedia","MUTE","peerId","UNMUTE","emit","JOIN","navigator","mediaDevices","getUserMedia","audio","createOffer","remoteUser","console","warn","name","RTCPeerConnection","iceServers","onicecandidate","event","RELAY_ICE","icecandidate","candidate","ontrack","streams","remoteStream","currentUser","settled","interval","setInterval","clearInterval","getTracks","forEach","track","addTrack","offer","setLocalDescription","RELAY_SDP","sessionDescription","close","list","filter","c","addIceCandidate","remoteSessionDescription","setRemoteDescription","RTCSessionDescription","type","connection","answer","createAnswer","mute","clientIdx","map","indexOf","allConnectedClients","JSON","parse","stringify","stop","LEAVE","off","provideRef","instance","handleMute","enabled"],"mappings":"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","sourcesContent":["import { useEffect, useState, useRef, useCallback } from 'react';\r\nimport { ACTIONS } from '../actions';\r\nimport socketInit from '../socket';\r\nimport freeice from 'freeice';\r\nimport { useStateWithCallback } from './useStateWithCallback';\r\n\r\nexport const useWebRTC = (roomId, user) => {\r\n    const [clients, setClients] = useStateWithCallback([]);\r\n    const audioElements = useRef({});\r\n    const connections = useRef({});\r\n    const socket = useRef(null);\r\n    const localMediaStream = useRef(null);\r\n    const clientsRef = useRef(null);\r\n\r\n    const addNewClient = useCallback(\r\n        (newClient, cb) => {\r\n            const lookingFor = clients.find(\r\n                (client) => client.id === newClient.id\r\n            );\r\n\r\n            if (lookingFor === undefined) {\r\n                setClients(\r\n                    (existingClients) => [...existingClients, newClient],\r\n                    cb\r\n                );\r\n            }\r\n        },\r\n        [clients, setClients]\r\n    );\r\n\r\n    useEffect(() => {\r\n        clientsRef.current = clients;\r\n    }, [clients]);\r\n\r\n    useEffect(() => {\r\n        const initChat = async () => {\r\n            socket.current = socketInit();\r\n            await captureMedia();\r\n            addNewClient({ ...user, muted: true }, () => {\r\n                const localElement = audioElements.current[user.id];\r\n                if (localElement) {\r\n                    localElement.volume = 0;\r\n                    localElement.srcObject = localMediaStream.current;\r\n                }\r\n            });\r\n            socket.current.on(ACTIONS.MUTE_INFO, ({ userId, isMute }) => {\r\n                handleSetMute(isMute, userId);\r\n            });\r\n\r\n            socket.current.on(ACTIONS.ADD_PEER, handleNewPeer);\r\n            socket.current.on(ACTIONS.REMOVE_PEER, handleRemovePeer);\r\n            socket.current.on(ACTIONS.ICE_CANDIDATE, handleIceCandidate);\r\n            socket.current.on(ACTIONS.SESSION_DESCRIPTION, setRemoteMedia);\r\n            socket.current.on(ACTIONS.MUTE, ({ peerId, userId }) => {\r\n                handleSetMute(true, userId);\r\n            });\r\n            socket.current.on(ACTIONS.UNMUTE, ({ peerId, userId }) => {\r\n                handleSetMute(false, userId);\r\n            });\r\n            socket.current.emit(ACTIONS.JOIN, {\r\n                roomId,\r\n                user,\r\n            });\r\n\r\n            async function captureMedia() {\r\n                // Start capturing local audio stream.\r\n                localMediaStream.current =\r\n                    await navigator.mediaDevices.getUserMedia({\r\n                        audio: true,\r\n                    });\r\n            }\r\n            async function handleNewPeer({\r\n                peerId,\r\n                createOffer,\r\n                user: remoteUser,\r\n            }) {\r\n                if (peerId in connections.current) {\r\n                    return console.warn(\r\n                        `You are already connected with ${peerId} (${user.name})`\r\n                    );\r\n                }\r\n\r\n                // Store it to connections\r\n                connections.current[peerId] = new RTCPeerConnection({\r\n                    iceServers: freeice(),\r\n                });\r\n\r\n                // Handle new ice candidate on this peer connection\r\n                connections.current[peerId].onicecandidate = (event) => {\r\n                    socket.current.emit(ACTIONS.RELAY_ICE, {\r\n                        peerId,\r\n                        icecandidate: event.candidate,\r\n                    });\r\n                };\r\n\r\n                // Handle on track event on this connection\r\n                connections.current[peerId].ontrack = ({\r\n                    streams: [remoteStream],\r\n                }) => {\r\n                    addNewClient({ ...remoteUser, muted: true }, () => {\r\n                        // get current users mute info\r\n                        const currentUser = clientsRef.current.find(\r\n                            (client) => client.id === user.id\r\n                        );\r\n                        if (currentUser) {\r\n                            socket.current.emit(ACTIONS.MUTE_INFO, {\r\n                                userId: user.id,\r\n                                roomId,\r\n                                isMute: currentUser.muted,\r\n                            });\r\n                        }\r\n                        if (audioElements.current[remoteUser.id]) {\r\n                            audioElements.current[remoteUser.id].srcObject =\r\n                                remoteStream;\r\n                        } else {\r\n                            let settled = false;\r\n                            const interval = setInterval(() => {\r\n                                if (audioElements.current[remoteUser.id]) {\r\n                                    audioElements.current[\r\n                                        remoteUser.id\r\n                                    ].srcObject = remoteStream;\r\n                                    settled = true;\r\n                                }\r\n\r\n                                if (settled) {\r\n                                    clearInterval(interval);\r\n                                }\r\n                            }, 300);\r\n                        }\r\n                    });\r\n                };\r\n\r\n                // Add connection to peer connections track\r\n                localMediaStream.current.getTracks().forEach((track) => {\r\n                    connections.current[peerId].addTrack(\r\n                        track,\r\n                        localMediaStream.current\r\n                    );\r\n                });\r\n\r\n                // Create an offer if required\r\n                if (createOffer) {\r\n                    const offer = await connections.current[\r\n                        peerId\r\n                    ].createOffer();\r\n\r\n                    // Set as local description\r\n                    await connections.current[peerId].setLocalDescription(\r\n                        offer\r\n                    );\r\n\r\n                    // send offer to the server\r\n                    socket.current.emit(ACTIONS.RELAY_SDP, {\r\n                        peerId,\r\n                        sessionDescription: offer,\r\n                    });\r\n                }\r\n            }\r\n            async function handleRemovePeer({ peerId, userId }) {\r\n                // Correction: peerID to peerId\r\n                if (connections.current[peerId]) {\r\n                    connections.current[peerId].close();\r\n                }\r\n\r\n                delete connections.current[peerId];\r\n                delete audioElements.current[peerId];\r\n                setClients((list) => list.filter((c) => c.id !== userId));\r\n            }\r\n            async function handleIceCandidate({ peerId, icecandidate }) {\r\n                if (icecandidate) {\r\n                    connections.current[peerId].addIceCandidate(icecandidate);\r\n                }\r\n            }\r\n            async function setRemoteMedia({\r\n                peerId,\r\n                sessionDescription: remoteSessionDescription,\r\n            }) {\r\n                connections.current[peerId].setRemoteDescription(\r\n                    new RTCSessionDescription(remoteSessionDescription)\r\n                );\r\n\r\n                // If session descrition is offer then create an answer\r\n                if (remoteSessionDescription.type === 'offer') {\r\n                    const connection = connections.current[peerId];\r\n\r\n                    const answer = await connection.createAnswer();\r\n                    connection.setLocalDescription(answer);\r\n\r\n                    socket.current.emit(ACTIONS.RELAY_SDP, {\r\n                        peerId,\r\n                        sessionDescription: answer,\r\n                    });\r\n                }\r\n            }\r\n            async function handleSetMute(mute, userId) {\r\n                const clientIdx = clientsRef.current\r\n                    .map((client) => client.id)\r\n                    .indexOf(userId);\r\n                const allConnectedClients = JSON.parse(\r\n                    JSON.stringify(clientsRef.current)\r\n                );\r\n                if (clientIdx > -1) {\r\n                    allConnectedClients[clientIdx].muted = mute;\r\n                    setClients(allConnectedClients);\r\n                }\r\n            }\r\n        };\r\n\r\n        initChat();\r\n        return () => {\r\n            localMediaStream.current\r\n                .getTracks()\r\n                .forEach((track) => track.stop());\r\n            socket.current.emit(ACTIONS.LEAVE, { roomId });\r\n            for (let peerId in connections.current) {\r\n                connections.current[peerId].close();\r\n                delete connections.current[peerId];\r\n                delete audioElements.current[peerId];\r\n            }\r\n            socket.current.off(ACTIONS.ADD_PEER);\r\n            socket.current.off(ACTIONS.REMOVE_PEER);\r\n            socket.current.off(ACTIONS.ICE_CANDIDATE);\r\n            socket.current.off(ACTIONS.SESSION_DESCRIPTION);\r\n            socket.current.off(ACTIONS.MUTE);\r\n            socket.current.off(ACTIONS.UNMUTE);\r\n        };\r\n    }, []);\r\n\r\n    const provideRef = (instance, userId) => {\r\n        audioElements.current[userId] = instance;\r\n    };\r\n\r\n    const handleMute = (isMute, userId) => {\r\n        let settled = false;\r\n\r\n        if (userId === user.id) {\r\n            let interval = setInterval(() => {\r\n                if (localMediaStream.current) {\r\n                    localMediaStream.current.getTracks()[0].enabled = !isMute;\r\n                    if (isMute) {\r\n                        socket.current.emit(ACTIONS.MUTE, {\r\n                            roomId,\r\n                            userId: user.id,\r\n                        });\r\n                    } else {\r\n                        socket.current.emit(ACTIONS.UNMUTE, {\r\n                            roomId,\r\n                            userId: user.id,\r\n                        });\r\n                    }\r\n                    settled = true;\r\n                }\r\n                if (settled) {\r\n                    clearInterval(interval);\r\n                }\r\n            }, 200);\r\n        }\r\n    };\r\n\r\n    return {\r\n        clients,\r\n        provideRef,\r\n        handleMute,\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}
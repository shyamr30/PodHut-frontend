{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useRef, useCallback, useEffect } from 'react';\nimport { useStateWithCallback } from './useStateWithCallback';\nimport { socketInit } from '../socket';\nimport { ACTIONS } from '../actions';\nimport freeice from 'freeice';\nexport const useWebRTC = (roomId, user) => {\n  _s();\n\n  const [clients, setClients] = useStateWithCallback([]);\n  const audioElements = useRef({});\n  const connections = useRef({});\n  const localMediaStream = useRef(null);\n  const socket = useRef(null);\n  useEffect(() => {\n    socket.current = socketInit();\n  }, []);\n  const addNewClient = useCallback((newClient, cb) => {\n    const lookingFor = clients.find(client => client.id === newClient.id);\n\n    if (lookingFor === undefined) {\n      setClients(existingClients => [...existingClients, newClient], cb);\n    }\n  }, [clients, setClients]); // Capture media\n\n  useEffect(() => {\n    const startCapture = async () => {\n      localMediaStream.current = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n    };\n\n    startCapture().then(() => {\n      addNewClient(user, () => {\n        const localElement = audioElements.current[user.id];\n\n        if (localElement) {\n          localElement.volume = 0;\n          localElement.srcObject = localMediaStream.current;\n        } // socket emit JOIN socket io\n\n\n        socket.current.emit(ACTIONS.JOIN, {\n          roomId,\n          user\n        });\n      });\n    });\n    return () => {\n      // Leaving the room\n      localMediaStream.current.getTracks().forEach(track => track.stop());\n      socket.current.emit(ACTIONS.LEAVE, {\n        roomId\n      });\n    };\n  }, []);\n  useEffect(() => {\n    const handleNewPeer = async _ref => {\n      let {\n        peerId,\n        createOffer,\n        user: remoteUser\n      } = _ref;\n\n      // if already connected then give warning\n      if (peerId in connections.current) {\n        return console.warn(`You are already connected with ${peerId} (${user.name})`);\n      }\n\n      connections.current[peerId] = new RTCPeerConnection({\n        iceServers: freeice()\n      }); // Handle new ice candidate\n\n      connections.current[peerId].onicecandidate = event => {\n        socket.current.emit(ACTIONS.RELAY_ICE, {\n          peerId,\n          icecandidate: event.candidate\n        });\n      }; // Handle on track on this connection\n\n\n      connections.current[peerId].ontrack = _ref2 => {\n        let {\n          streams: [remoteStream]\n        } = _ref2;\n        addNewClient(remoteUser, () => {\n          if (audioElements.current[remoteUser.id]) {\n            audioElements.current[remoteUser.id].srcObject = remoteStream;\n          } else {\n            let settled = false;\n            const interval = setInterval(() => {\n              if (audioElements.current[remoteUser.id]) {\n                audioElements.current[remoteUser.id].srcObject = remoteStream;\n                settled = true;\n              }\n\n              if (settled) {\n                clearInterval(interval);\n              }\n            }, 1000);\n          }\n        });\n      }; // Add local track to remote connections\n\n\n      localMediaStream.current.getTracks().forEach(track => {\n        connections.current[peerId].addTrack(track, localMediaStream.current);\n      }); // Create offer\n\n      if (createOffer) {\n        const offer = await connections.current[peerId].createOffer();\n        await connections.current[peerId].setLocalDescription(offer); // send offer to another client\n\n        socket.current.emit(ACTIONS.RELAY_SDP, {\n          peerId,\n          sessionDescription: offer\n        });\n      }\n    };\n\n    socket.current.on(ACTIONS.ADD_PEER, handleNewPeer);\n    return () => {\n      socket.current.off(ACTIONS.ADD_PEER);\n    };\n  }, []); // Handle ice candidate\n\n  useEffect(() => {\n    socket.current.on(ACTIONS.ICE_CANDIDATE, _ref3 => {\n      let {\n        peerId,\n        icecandidate\n      } = _ref3;\n\n      if (icecandidate) {\n        connections.current[peerId].addIceCandidate(icecandidate);\n      }\n    });\n    return () => {\n      socket.current.off(ACTIONS.ICE_CANDIDATE);\n    };\n  }, []); // Handle SDP\n\n  useEffect(() => {\n    const handleRemoteSdp = async _ref4 => {\n      let {\n        peerId,\n        sessionDescription: remoteSessionDescription\n      } = _ref4;\n      connections.current[peerId].setRemoteDescription(new RTCSessionDescription(remoteSessionDescription)); // if session description is type of offer then create an answer\n\n      if (remoteSessionDescription.type === 'offer') {\n        const connection = connections.current[peerId];\n        const answer = await connection.createAnswer();\n        connection.setLocalDescription(answer);\n        socket.current.emit(ACTIONS.RELAY_SDP, {\n          peerId,\n          sessionDescription: answer\n        });\n      }\n    };\n\n    socket.current.on(ACTIONS.SESSION_DESCRIPTION, handleRemoteSdp);\n    return () => {\n      socket.current.off(ACTIONS.SESSION_DESCRIPTION);\n    };\n  }, []); // Handle remove peer\n\n  useEffect(() => {\n    const handleRemovePeer = async _ref5 => {\n      let {\n        peerId,\n        userId\n      } = _ref5;\n\n      if (connections.current[peerId]) {\n        connections.current[peerId].close();\n      }\n\n      delete connections.current[peerId];\n      delete audioElements.current[peerId];\n      setClients(list => list.filter(client => client.id !== userId));\n    };\n\n    socket.current.on(ACTIONS.REMOVE_PEER, handleRemovePeer);\n    return () => {\n      socket.current.off(ACTIONS.REMOVE_PEER);\n    };\n  }, []);\n\n  const provideRef = (instance, userId) => {\n    audioElements.current[userId] = instance;\n  };\n\n  return {\n    clients,\n    provideRef\n  };\n};\n\n_s(useWebRTC, \"ksM9rSuLqu6dP4rwJKw4UMLpEwY=\", false, function () {\n  return [useStateWithCallback];\n});","map":{"version":3,"sources":["E:/College Assignment/Sem 6/SDP Project/project/frontend/src/hooks/useWebRTC.js"],"names":["useRef","useCallback","useEffect","useStateWithCallback","socketInit","ACTIONS","freeice","useWebRTC","roomId","user","clients","setClients","audioElements","connections","localMediaStream","socket","current","addNewClient","newClient","cb","lookingFor","find","client","id","undefined","existingClients","startCapture","navigator","mediaDevices","getUserMedia","audio","then","localElement","volume","srcObject","emit","JOIN","getTracks","forEach","track","stop","LEAVE","handleNewPeer","peerId","createOffer","remoteUser","console","warn","name","RTCPeerConnection","iceServers","onicecandidate","event","RELAY_ICE","icecandidate","candidate","ontrack","streams","remoteStream","settled","interval","setInterval","clearInterval","addTrack","offer","setLocalDescription","RELAY_SDP","sessionDescription","on","ADD_PEER","off","ICE_CANDIDATE","addIceCandidate","handleRemoteSdp","remoteSessionDescription","setRemoteDescription","RTCSessionDescription","type","connection","answer","createAnswer","SESSION_DESCRIPTION","handleRemovePeer","userId","close","list","filter","REMOVE_PEER","provideRef","instance"],"mappings":"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","sourcesContent":["import { useRef, useCallback, useEffect } from 'react';\r\nimport { useStateWithCallback } from './useStateWithCallback';\r\nimport { socketInit } from '../socket';\r\nimport { ACTIONS } from '../actions';\r\nimport freeice from 'freeice';\r\n\r\nexport const useWebRTC = (roomId, user) => {\r\n    const [clients, setClients] = useStateWithCallback([]);\r\n    const audioElements = useRef({});\r\n    const connections = useRef({});\r\n    const localMediaStream = useRef(null);\r\n    const socket = useRef(null);\r\n\r\n    useEffect(() => {\r\n        socket.current = socketInit();\r\n    }, []);\r\n\r\n    const addNewClient = useCallback(\r\n        (newClient, cb) => {\r\n            const lookingFor = clients.find(\r\n                (client) => client.id === newClient.id\r\n            );\r\n\r\n            if (lookingFor === undefined) {\r\n                setClients(\r\n                    (existingClients) => [...existingClients, newClient],\r\n                    cb\r\n                );\r\n            }\r\n        },\r\n        [clients, setClients]\r\n    );\r\n\r\n    // Capture media\r\n\r\n    useEffect(() => {\r\n        const startCapture = async () => {\r\n            localMediaStream.current =\r\n                await navigator.mediaDevices.getUserMedia({\r\n                    audio: true,\r\n                });\r\n        };\r\n\r\n        startCapture().then(() => {\r\n            addNewClient(user, () => {\r\n                const localElement = audioElements.current[user.id];\r\n                if (localElement) {\r\n                    localElement.volume = 0;\r\n                    localElement.srcObject = localMediaStream.current;\r\n                }\r\n\r\n                // socket emit JOIN socket io\r\n                socket.current.emit(ACTIONS.JOIN, { roomId, user });\r\n            });\r\n        });\r\n\r\n        return () => {\r\n            // Leaving the room\r\n            localMediaStream.current\r\n                .getTracks()\r\n                .forEach((track) => track.stop());\r\n\r\n            socket.current.emit(ACTIONS.LEAVE, { roomId });\r\n        };\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        const handleNewPeer = async ({\r\n            peerId,\r\n            createOffer,\r\n            user: remoteUser,\r\n        }) => {\r\n            // if already connected then give warning\r\n            if (peerId in connections.current) {\r\n                return console.warn(\r\n                    `You are already connected with ${peerId} (${user.name})`\r\n                );\r\n            }\r\n\r\n            connections.current[peerId] = new RTCPeerConnection({\r\n                iceServers: freeice(),\r\n            });\r\n\r\n            // Handle new ice candidate\r\n            connections.current[peerId].onicecandidate = (event) => {\r\n                socket.current.emit(ACTIONS.RELAY_ICE, {\r\n                    peerId,\r\n                    icecandidate: event.candidate,\r\n                });\r\n            };\r\n\r\n            // Handle on track on this connection\r\n\r\n            connections.current[peerId].ontrack = ({\r\n                streams: [remoteStream],\r\n            }) => {\r\n                addNewClient(remoteUser, () => {\r\n                    if (audioElements.current[remoteUser.id]) {\r\n                        audioElements.current[remoteUser.id].srcObject =\r\n                            remoteStream;\r\n                    } else {\r\n                        let settled = false;\r\n                        const interval = setInterval(() => {\r\n                            if (audioElements.current[remoteUser.id]) {\r\n                                audioElements.current[remoteUser.id].srcObject =\r\n                                    remoteStream;\r\n                                settled = true;\r\n                            }\r\n                            if (settled) {\r\n                                clearInterval(interval);\r\n                            }\r\n                        }, 1000);\r\n                    }\r\n                });\r\n            };\r\n\r\n            // Add local track to remote connections\r\n            localMediaStream.current.getTracks().forEach((track) => {\r\n                connections.current[peerId].addTrack(\r\n                    track,\r\n                    localMediaStream.current\r\n                );\r\n            });\r\n\r\n            // Create offer\r\n            if (createOffer) {\r\n                const offer = await connections.current[peerId].createOffer();\r\n\r\n                await connections.current[peerId].setLocalDescription(offer);\r\n\r\n                // send offer to another client\r\n                socket.current.emit(ACTIONS.RELAY_SDP, {\r\n                    peerId,\r\n                    sessionDescription: offer,\r\n                });\r\n            }\r\n        };\r\n\r\n        socket.current.on(ACTIONS.ADD_PEER, handleNewPeer);\r\n\r\n        return () => {\r\n            socket.current.off(ACTIONS.ADD_PEER);\r\n        };\r\n    }, []);\r\n\r\n    // Handle ice candidate\r\n    useEffect(() => {\r\n        socket.current.on(ACTIONS.ICE_CANDIDATE, ({ peerId, icecandidate }) => {\r\n            if (icecandidate) {\r\n                connections.current[peerId].addIceCandidate(icecandidate);\r\n            }\r\n        });\r\n\r\n        return () => {\r\n            socket.current.off(ACTIONS.ICE_CANDIDATE);\r\n        };\r\n    }, []);\r\n\r\n    // Handle SDP\r\n    useEffect(() => {\r\n        const handleRemoteSdp = async ({\r\n            peerId,\r\n            sessionDescription: remoteSessionDescription,\r\n        }) => {\r\n            connections.current[peerId].setRemoteDescription(\r\n                new RTCSessionDescription(remoteSessionDescription)\r\n            );\r\n\r\n            // if session description is type of offer then create an answer\r\n\r\n            if (remoteSessionDescription.type === 'offer') {\r\n                const connection = connections.current[peerId];\r\n                const answer = await connection.createAnswer();\r\n\r\n                connection.setLocalDescription(answer);\r\n\r\n                socket.current.emit(ACTIONS.RELAY_SDP, {\r\n                    peerId,\r\n                    sessionDescription: answer,\r\n                });\r\n            }\r\n        };\r\n        socket.current.on(ACTIONS.SESSION_DESCRIPTION, handleRemoteSdp);\r\n\r\n        return () => {\r\n            socket.current.off(ACTIONS.SESSION_DESCRIPTION);\r\n        };\r\n    }, []);\r\n\r\n    // Handle remove peer\r\n    useEffect(() => {\r\n        const handleRemovePeer = async ({ peerId, userId }) => {\r\n            if (connections.current[peerId]) {\r\n                connections.current[peerId].close();\r\n            }\r\n\r\n            delete connections.current[peerId];\r\n            delete audioElements.current[peerId];\r\n            setClients((list) => list.filter((client) => client.id !== userId));\r\n        };\r\n\r\n        socket.current.on(ACTIONS.REMOVE_PEER, handleRemovePeer);\r\n\r\n        return () => {\r\n            socket.current.off(ACTIONS.REMOVE_PEER);\r\n        };\r\n    }, []);\r\n\r\n    const provideRef = (instance, userId) => {\r\n        audioElements.current[userId] = instance;\r\n    };\r\n\r\n    return { clients, provideRef };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}